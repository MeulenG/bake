/**
 * Copyright 2024, Philip Meulengracht
 *
 * This program is free software : you can redistribute it and / or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation ? , either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 * 
 */

#include <chef/list.h>
#include <chef/platform.h>
#include <errno.h>
#include <libingredient.h>
#include "pkgmngrs.h"
#include <stdio.h>

struct pkgconfig {
    struct pkgmngr base;
    char*          root;
};

static int __make_available(const char* hostRoot, const char* root, struct ingredient* ingredient)
{
    FILE* file;
    char  pcName[256];
    char* pcPath;
    int   written;
    int   status;
    char* cflags;
    char* libs;

    if (ingredient->options == NULL) {
        // Can't add a pkg-config file if the ingredient didn't specify any
        // options for consumers.
        // TODO: Add defaults?
        return 0;
    }

    // The package name specified on the pkg-config command line is defined 
    // to be the name of the metadata file, minus the .pc extension. Optionally
    // the version can be appended as name-1.0
    written = snprintf(&pcName[0], sizeof(pcName) - 1, "%s.pc", ingredient->package->package);
    if (written == (sizeof(pcName) - 1)) {
        errno = E2BIG;
        return -1;
    }
    
    pcPath = strpathjoin(hostRoot, "/usr/share/pkgconfig/", &pcName[0], NULL);
    if (pcPath == NULL) {
        return -1;
    }
    
    file = fopen(pcPath, "w");
    if(!file) {
        VLOG_ERROR("kitchen", "__make_available: failed to open %s for writing: %s\n", pcPath, strerror(errno));
        free(pcPath);
        return -1;
    }

    cflags = __string_array_join((const char* const*)ingredient->options->inc_dirs, "-I{prefix}", " ");
    libs = __string_array_join((const char* const*)ingredient->options->lib_dirs, "-L{prefix}", " ");
    if (cflags == NULL || libs == NULL) {
        free(cflags);
        free(libs);
        fclose(file);
        return -1;
    }

    fprintf(file, "# generated by chef, please do not manually modify this\n");
    fprintf(file, "prefix=%s\n", root);

    fprintf(file, "Name: %s\n", ingredient->package->package);
    fprintf(file, "Description: %s by %s\n", ingredient->package->package, ingredient->package->publisher);
    fprintf(file, "Version: %i.%i.%i\n", ingredient->version->major, ingredient->version->minor, ingredient->version->patch);
    fprintf(file, "Cflags: %s\n", cflags);
    fprintf(file, "Libs: %s\n", libs);
    free(cflags);
    free(libs);
    return fclose(file);
}

static struct chef_keypair_item* __compose_keypair(const char* key, const char* value)
{
    struct chef_keypair_item* item = calloc(sizeof(struct chef_keypair_item), 1);
    if (item == NULL) {
        return NULL;
    }
    item->key = strdup(key);
    if (item->key == NULL) {
        free(item);
    }
    item->value = strdup(value);
    if (item->value == NULL) {
        free(item->key);
        free(item);
    }
    return item;
}

static int __add_or_replace_pkgconfig_paths(struct list* environment, const char* pkgconfigRoot)
{
    // Look and update/add the following language flags to account for
    // ingredient include paths
    struct list_item* item;
    struct {
        const char* ident;
        int         fixed;
    } idents[] = {
        { "PKG_CONFIG_PATH", 0 },
        { "PKG_CONFIG_LIBDIR", 0 },
        { NULL, 0 }
    };

    // Replace any environmental variable already provided by recipe
    list_foreach(environment, item) {
        struct chef_keypair_item* keypair = (struct chef_keypair_item*)item;
        for (int i = 0; idents[i].ident != NULL; i++) {
            if (!strcmp(keypair->key, idents[i].ident)) {
                const char* tmp = keypair->value;
                keypair->value = strdup(pkgconfigRoot);
                if (keypair->value == NULL) {
                    keypair->value = tmp;
                    return -1;
                }
                free((void*)tmp);
                idents[i].fixed = 1;
            }
        }
    }

    // Add any that was not provided
    for (int i = 0; idents[i].ident != NULL; i++) {
        if (!idents[i].fixed) {
            item = (struct list_item*)__compose_keypair(idents[i].ident, pkgconfigRoot);
            if (item == NULL) {
                return -1;
            }
            list_add(environment, item);
        }
    }
    return 0;
}

static void __destroy(struct pkgmngr* pkgmngr)
{
    struct pkgconfig* pkgconfig = (struct pkgconfig*)pkgmngr;
    if (pkgconfig != NULL) {
        free(pkgconfig->root);
    }
    free(pkgconfig);
}

struct pkgmngr* pkgmngr_pkgconfig_new(const char* root)
{
    struct pkgconfig* pkgconfig;

    pkgconfig = malloc(sizeof(struct pkgconfig));
    if (pkgconfig == NULL) {
        return NULL;
    }

    pkgconfig->base.make_available = __make_available;
    pkgconfig->base.add_overrides  = __add_or_replace_pkgconfig_paths;
    pkgconfig->base.destroy        = __destroy;
    pkgconfig->root = strdup(root);
    if (pkgconfig->root == NULL) {
        free(pkgconfig);
        return NULL;
    }
    return &pkgconfig->base;
}
