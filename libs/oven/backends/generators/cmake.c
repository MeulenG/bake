/**
 * Copyright 2022, Philip Meulengracht
 *
 * This program is free software : you can redistribute it and / or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation ? , either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 * 
 */

#include <backend.h>
#include <errno.h>
#include <liboven.h>
#include <chef/platform.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <utils.h>

static const char* g_cmakeTemplate = 
"# This file is generated by chef please don't edit it.\n"
"# The arguments listed there are the one used by the last generation of this file.\n"
"#\n"
"# Please take a look at what we're doing there if you are curious!\n"
"# If you have feedback or improvements, please open an issue at our github tracker:\n"
"#\n"
"#    https://github.com/meulengracht/bake/issues\n"
"#\n"
"set(CHEF_CMAKE_{{PROJECT_NAME}} ON)\n"
"set(CHEF_CMAKE ON)\n"
"set(CHEF_CMAKE_{{PROJECT_NAME}}_PROFILE \"{{PROFILE_NAME}}\")\n"
"set(CHEF_CMAKE_PROFILE \"{{PROFILE_NAME}}\")\n";

char* __replace(char* text, const char* find, const char* replaceWith)
{
    char* result = strreplace(text, find, replaceWith);
    if (result == NULL) {
        return NULL;
    }
    free(text);
    return result;
}

static int __write_header(FILE* file, const char* projectName, const char* profileName)
{
    char* cmake;

    cmake = strdup(g_cmakeTemplate);
    if (cmake == NULL) {
        errno = ENOMEM;
        return -1;
    }
    
    cmake = __replace(cmake, "{{PROJECT_NAME}}", projectName);
    cmake = __replace(cmake, "{{PROFILE_NAME}}", profileName);

    fwrite(cmake, strlen(cmake), 1, file);
    free(cmake);
    return 0;
}

static int __write_prefix(FILE* file, const char* prefixPath)
{
    fprintf(file, "\n# setup the prefix path\n");
    fprintf(file, "list(APPEND CMAKE_PREFIX_PATH \"%s\")\n", prefixPath);
    return 0;
}

static int __write_include(FILE* file, const char* includePath)
{
    fprintf(file, "\n# setup additional include paths for code\n");
    fprintf(file, "include_directories(\"%s/include\")\n", includePath);
    return 0;
}

static int __generate_cmake_file(const char* path, struct oven_backend_data* data)
{
    FILE* file;
    int   status;

    file = fopen(path, "w");
    if(!file) {
        fprintf(stderr, "Failed to open workspace.cmake for writing: %s\n", strerror(errno));
        return -1;
    }

    status = __write_header(file, data->project_name, data->profile_name);
    if (status != 0) {
        goto cleanup;
    }

    if (data->fridge_directory) {
        status = __write_prefix(file, data->fridge_directory);
        if (status != 0) {
            goto cleanup;
        }
        
        status = __write_include(file, data->fridge_directory);
        if (status != 0) {
            goto cleanup;
        }
    }

cleanup:
    fclose(file);
    return status;
}

int cmake_main(struct oven_backend_data* data, union oven_backend_options* options)
{
    char*  workspacePath;
    char*  argument    = NULL;
    char** environment = NULL;
    int    written;
    int    status = -1;
    size_t argumentLength;

    workspacePath = strpathcombine(data->build_directory, "workspace.cmake");
    if (workspacePath == NULL) {
        return -1;
    }

    argumentLength = strlen(data->arguments) + 1024;
    argument       = malloc(argumentLength);
    if (argument == NULL) {
        goto cleanup;
    }

    environment = oven_environment_create(data->process_environment, data->environment);
    if (environment == NULL) {
        free(argument);
        goto cleanup;
    }

    status = __generate_cmake_file(workspacePath, data);
    if (status != 0) {
        goto cleanup;
    }

    // build the cmake command, execute from build folder
    // if cross compiling set -DCMAKE_FIND_USE_CMAKE_SYSTEM_PATH=OFF
    written = snprintf(
        argument,
        argumentLength - 1,
        "%s -DCMAKE_PROJECT_INCLUDE=%s -DCMAKE_INSTALL_PREFIX=%s %s",
        data->arguments,
        workspacePath,
        data->install_directory,
        data->project_directory
    );
    argument[written] = '\0';

    // perform the spawn operation
    printf("oven-cmake: executing 'cmake %s'\n", argument);
    status = platform_spawn("cmake", argument, (const char* const*)environment, data->build_directory);
    
cleanup:
    oven_environment_destroy(environment);
    free(argument);
    free(workspacePath);
    return status;
}
