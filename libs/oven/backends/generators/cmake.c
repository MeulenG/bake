/**
 * Copyright 2022, Philip Meulengracht
 *
 * This program is free software : you can redistribute it and / or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation ? , either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 * 
 */

#include <backend.h>
#include <errno.h>
#include <liboven.h>
#include <chef/platform.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <utils.h>

static const char* g_cmakeTemplate = 
"# This file is generated by chef please don't edit it.\n"
"# The arguments listed there are the one used by the last generation of this file.\n"
"#\n"
"# Please take a look at what we're doing there if you are curious!\n"
"# If you have feedback or improvements, please open an issue at our github tracker:\n"
"#\n"
"#    https://github.com/meulengracht/bake/issues\n"
"#\n"
"set(CHEF_CMAKE_{{PROJECT_NAME}} ON)\n"
"set(CHEF_CMAKE ON)\n"
"set(CHEF_CMAKE_{{PROJECT_NAME}}_PROFILE \"{{PROFILE_NAME}}\")\n"
"set(CHEF_CMAKE_PROFILE \"{{PROFILE_NAME}}\")\n";

char* __replace(char* text, const char* find, const char* replaceWith)
{
    char* result = strreplace(text, find, replaceWith);
    if (result == NULL) {
        return NULL;
    }
    free(text);
    return result;
}

static int __write_header(FILE* file, const char* projectName, const char* profileName)
{
    char* cmake;

    cmake = strdup(g_cmakeTemplate);
    if (cmake == NULL) {
        errno = ENOMEM;
        return -1;
    }
    
    cmake = __replace(cmake, "{{PROJECT_NAME}}", projectName);
    cmake = __replace(cmake, "{{PROFILE_NAME}}", profileName);

    fwrite(cmake, strlen(cmake), 1, file);
    free(cmake);
    return 0;
}

static void __write_linux_prefix(FILE* file, const char* prefixPath)
{
    fprintf(file, "\n# setup the linux environment paths\n");
    fprintf(file, "list(APPEND CMAKE_PREFIX_PATH \"%s\")\n", prefixPath);
    fprintf(file, "list(APPEND CMAKE_PREFIX_PATH \"%s/usr\")\n", prefixPath);
    fprintf(file, "list(APPEND CMAKE_PREFIX_PATH \"%s/usr/local\")\n", prefixPath);
}

static void __write_linux_include(FILE* file, const char* includePath)
{
    fprintf(file, "\n# setup additional include paths for linux code environment\n");
    fprintf(file, "include_directories(\"%s/include\")\n", includePath);
    fprintf(file, "include_directories(\"%s/usr/include\")\n", includePath);
    fprintf(file, "include_directories(\"%s/usr/local/include\")\n", includePath);
}

static void __write_windows_prefix(FILE* file, const char* prefixPath)
{
    fprintf(file, "\n# setup the windows environment paths\n");
    fprintf(file, "list(APPEND CMAKE_PREFIX_PATH \"%s\")\n", prefixPath);
    fprintf(file, "list(APPEND CMAKE_PREFIX_PATH \"%s/Program Files\")\n", prefixPath);
}

static void __write_windows_include(FILE* file, const char* includePath)
{
    fprintf(file, "\n# setup additional include paths for windows code environment\n");
    fprintf(file, "include_directories(\"%s/Program Files/include\")\n", includePath);
}

static void __write_default_prefix(FILE* file, const char* prefixPath)
{
    fprintf(file, "\n# setup the default environment path\n");
    fprintf(file, "list(APPEND CMAKE_PREFIX_PATH \"%s\")\n", prefixPath);
}

static void __write_default_include(FILE* file, const char* includePath)
{
    fprintf(file, "\n# setup additional include paths for code\n");

    // Issue: these do not work, they need to appear after project()
    //fprintf(file, "list(APPEND CMAKE_INCLUDE_PATH \"%s/include\")\n", includePath);
    //fprintf(file, "include_directories(AFTER SYSTEM \"%s/include\")\n", includePath);

    // Issue: this adds -system includes which can break system libraries includes.
    //fprintf(file, "set(CMAKE_C_STANDARD_INCLUDE_DIRECTORIES \"%s/include\")\n", includePath);
    //fprintf(file, "set(CMAKE_CXX_STANDARD_INCLUDE_DIRECTORIES \"%s/include\")\n", includePath);
}

static int __generate_cmake_file(const char* path, struct oven_backend_data* data)
{
    FILE* file;
    int   status;

    file = fopen(path, "w");
    if(!file) {
        fprintf(stderr, "Failed to open workspace.cmake for writing: %s\n", strerror(errno));
        return -1;
    }

    status = __write_header(file, data->project_name, data->profile_name);
    if (status != 0) {
        goto cleanup;
    }

    /*if (data->paths.ingredients) {
        if (strcmp(data->platform.target_platform, "linux") == 0) {
            __write_linux_prefix(file, data->paths.ingredients);
            __write_linux_include(file, data->paths.ingredients);
        } else if (strcmp(data->platform.target_platform, "windows") == 0) {
            __write_windows_prefix(file, data->paths.ingredients);
            __write_windows_include(file, data->paths.ingredients);
        } else {
            __write_default_prefix(file, data->paths.ingredients);
            __write_default_include(file, data->paths.ingredients);
        }
    }*/

cleanup:
    fclose(file);
    return status;
}

// TODO this exists in both autotools and cmake backend, move to a common
// directory?
static const char* __get_cmake_default_install_path(const char* platform)
{
    if (strcmp(platform, "windows") == 0) {
        return "Program Files";
    } else if (strcmp(platform, "linux") == 0) {
        return "/usr/local";
    } else if (strcmp(platform, "vali") == 0) {
        return "";
    } else {
        return "";
    }
}

static char* __add_cmake_prefix(const char* platform, const char* arguments, const char* installPath)
{
    // build a new argument string with the prefix added
    char* newArguments = malloc(strlen(arguments) + 1024);
    char* defaultInstallPath = strpathcombine(installPath, __get_cmake_default_install_path(platform));
    if (newArguments == NULL || defaultInstallPath == NULL) {
        free(newArguments);
        free(defaultInstallPath);
        return NULL;
    }

    sprintf(newArguments, "%s -DCMAKE_INSTALL_PREFIX=%s", arguments, defaultInstallPath);
    free(defaultInstallPath);
    return newArguments;
}

static char* __replace_or_add_cmake_prefix(const char* platform, const char* arguments, const char* installPath)
{
    char* prefix = strstr(arguments, "CMAKE_INSTALL_PREFIX=");
    char* newArguments;
    char* oldPath;
    char* newPath;
    char* startOfValue;
    char* endOfValue;

    if (!prefix) {
        return __add_cmake_prefix(platform, arguments, installPath);
    }

    // replace the prefix with the new one
    startOfValue = prefix + 21; // 'CMAKE_INSTALL_PREFIX=' is 21 characters long
    endOfValue   = strchr(startOfValue, ' ');
    if (!endOfValue) {
        endOfValue = strchr(startOfValue, '\0');
    }

    oldPath      = strndup(startOfValue, endOfValue - startOfValue);
    newArguments = malloc(strlen(arguments) + 1024);
    if (oldPath == NULL|| newArguments == NULL) {
        free(oldPath);
        free(newArguments);
        return NULL;
    }

    // build the new path which is a combination of oldPath and install directory
    newPath = strpathcombine(installPath, oldPath);
    if (newPath == NULL) {
        free(oldPath);
        free(newArguments);
        return NULL;
    }

    strncpy(newArguments, arguments, prefix - arguments);
    strcat(newArguments, "CMAKE_INSTALL_PREFIX=");
    strcat(newArguments, newPath);
    if (*endOfValue) {
        strcat(newArguments, endOfValue);
    }

    free(oldPath);
    free(newPath);
    return newArguments;
}

int cmake_main(struct oven_backend_data* data, union oven_backend_options* options)
{
    char*  workspacePath;
    char*  argument    = NULL;
    char*  newArguments;
    char** environment = NULL;
    int    written;
    int    status = -1;
    size_t argumentLength;

    workspacePath = strpathcombine(data->paths.build, "workspace.cmake");
    newArguments  = __replace_or_add_cmake_prefix(
        data->platform.target_platform,
        data->arguments,
        data->paths.install
    );
    if (workspacePath == NULL || newArguments == NULL) {
        free(workspacePath);
        free(newArguments);
        return -1;
    }

    argumentLength = strlen(newArguments) + 1024;
    argument       = malloc(argumentLength);
    if (argument == NULL) {
        goto cleanup;
    }

    environment = oven_environment_create(data->process_environment, data->environment);
    if (environment == NULL) {
        free(argument);
        goto cleanup;
    }

    if (options == NULL) {
        status = __generate_cmake_file(workspacePath, data);
        if (status != 0) {
            goto cleanup;
        }

        // build the cmake command, execute from build folder
        // if cross compiling set -DCMAKE_FIND_USE_CMAKE_SYSTEM_PATH=OFF
        written = snprintf(
            argument,
            argumentLength - 1,
            "%s -DCMAKE_PROJECT_INCLUDE=%s %s",
            newArguments,
            workspacePath,
            data->paths.project
        );
    } else {
        written = snprintf(
            argument,
            argumentLength - 1,
            "%s %s",
            newArguments,
            data->paths.project
        );
    }
    argument[written] = '\0';

    // perform the spawn operation
    printf("oven-cmake: executing 'cmake %s'\n", argument);
    status = platform_spawn(
        "cmake",
        argument,
        (const char* const*)environment,
        data->paths.build
    );
    
cleanup:
    oven_environment_destroy(environment);
    free(argument);
    free(workspacePath);
    free(newArguments);
    return status;
}
