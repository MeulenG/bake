/**
 * Copyright 2023, Philip Meulengracht
 *
 * This program is free software : you can redistribute it and / or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation ? , either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 * 
 */

#include <errno.h>
#include "../private.h"
#include <chef/platform.h>
#include <libingredient.h>
#include <liboven.h>
#include <stdlib.h>
#include <string.h>
#include <vlog.h>

static int __make_available(const char* root, struct ingredient* ingredient)
{
    FILE* file;
    char  pcName[256];
    char* pc_path;
    int   written;
    int   status;

    // The package name specified on the pkg-config command line is defined 
    // to be the name of the metadata file, minus the .pc extension. Optionally
    // the version can be appended as name-1.0
    written = snprintf(&pcName[0], sizeof(pcName) - 1, "%s.pc", ingredient->package->package);
    if (written == (sizeof(pcName) - 1)) {
        errno = E2BIG;
        return -1;
    }
    
    pc_path = strpathcombine("/usr/share/pkgconfig", &pcName[0]);
    if (pc_path == NULL) {
        return -1;
    }
    
    file = fopen(pc_path, "w");
    if(!file) {
        VLOG_ERROR("oven", "__make_available: failed to open %s for writing: %s\n", pc_path, strerror(errno));
        free(pc_path);
        return -1;
    }

   fprintf(file, "# generated by chef, please do not manually modify this\n");
   fprintf(file, "prefix=/usr/lib\n");
   fprintf(file, "exec_prefix=${prefix}\n");
   fprintf(file, "includedir=${prefix}/include\n");
   fprintf(file, "libdir=${exec_prefix}/lib\n\n");

   fprintf(file, "Name: %s\n", ingredient->package->package);
   fprintf(file, "Description: %s by %s\n", ingredient->package->package, ingredient->package->publisher);
   fprintf(file, "Version: %i.%i.%i\n", ingredient->version->major, ingredient->version->minor, ingredient->version->patch);
   fprintf(file, "Cflags: -I${includedir}/foo\n");
   fprintf(file, "Libs: -L${libdir}\n");

   return fclose(file);
}

static int __setup_ingredients(const char* root, struct list* ingredients)
{
    struct list_item* i;
    int               status;

    if (ingredients == NULL) {
        return 0;
    }

    list_foreach(ingredients, i) {
        struct oven_ingredient* ovenIngredient = (struct oven_ingredient*)i;
        struct ingredient*      ingredient;

        status = ingredient_open(ovenIngredient->file_path, &ingredient);
        if (status) {
            VLOG_ERROR("oven", "__setup_ingredients: failed to open %s", ovenIngredient->name);
            return -1;
        }

        status = ingredient_unpack(ingredient, root, NULL, NULL);
        if (status) {
            ingredient_close(ingredient);
            VLOG_ERROR("oven", "__setup_ingredients: failed to setup %s", ovenIngredient->name);
            return -1;
        }

        status = __make_available(root, ingredient);
        ingredient_close(ingredient);
        if (status) {
            VLOG_ERROR("oven", "__setup_ingredients: failed to make %s available", ovenIngredient->name);
            return -1;
        }
    }
    return 0;
}

static char* __build_include_string(struct list* imports)
{
    struct list_item* i;
    char*             buffer;

    // --include=nano,gcc,clang,tcc,pcc,g++,git,make
    if (imports == NULL || imports->count == 0) {
        return NULL;
    }

    buffer = calloc(4096, 1); 
    if (buffer == NULL) {
        return NULL;
    }

    list_foreach(imports, i) {
        struct oven_package_import* import = (struct oven_package_import*)i;
        if (buffer[0] == 0) {
            strcpy(buffer, "--include=");
            strcat(buffer, import->name);
        } else {
            strcat(buffer, ",");
            strcat(buffer, import->name);
        }
    }
    return buffer;
}

static unsigned int __hash(unsigned int hash, const char* data, size_t length)
{
    for (unsigned int i = 0; i < length; i++) {
        unsigned char c = (unsigned char)data[i];
        hash = ((hash << 5) + hash) + c;
    }
    return hash;
}

// hash of ingredients and imports
static unsigned int __setup_hash(struct scratch_options* options)
{
    unsigned int      hash = 5381;
    struct list_item* i;

    // hash name
    hash = __hash(hash, options->name, strlen(options->name));

    // hash ingredients
    if (options->ingredients != NULL) {
        list_foreach(options->ingredients, i) {
            struct oven_ingredient* ovenIngredient = (struct oven_ingredient*)i;
            hash = __hash(hash, ovenIngredient->name, strlen(ovenIngredient->name));
        }
    }
    
    // hash imports
    if (options->imports != NULL) {
        list_foreach(options->imports, i) {
            struct oven_package_import* import = (struct oven_package_import*)i;
            hash = __hash(hash, import->name, strlen(import->name));
        }
    }
    return hash;
}

static unsigned int __read_hash(const char* name)
{
    char  scratchPad[512];
    FILE* hashFile;
    long  size;
    char* end = NULL;
    VLOG_TRACE("oven", "__read_hash()");

    snprintf(&scratchPad[0], sizeof(scratchPad), ".oven/%s/chef/.hash", name);
    hashFile = fopen(&scratchPad[0], "r");
    if (hashFile == NULL) {
        VLOG_TRACE("oven", "__read_hash: no hash file");
        return 0;
    }

    fseek(hashFile, 0, SEEK_END);
    size = ftell(hashFile);
    rewind(hashFile);

    if (size >= sizeof(scratchPad)) {
        VLOG_ERROR("oven", "__read_hash: the hash file was invalid");
        fclose(hashFile);
        return 0;
    }
    if (fread(&scratchPad[0], 1, size, hashFile) < size) {
        VLOG_ERROR("oven", "__read_hash: failed to read hash file");
        fclose(hashFile);
        return 0;
    }
    
    fclose(hashFile);
    return (unsigned int)strtoul(&scratchPad[0], &end, 10);
}

static int __write_hash(struct scratch_options* options)
{
    char         scratchPad[512];
    FILE*        hashFile;
    unsigned int hash;
    VLOG_TRACE("oven", "__write_hash(name=%s)", options->name);

    snprintf(&scratchPad[0], sizeof(scratchPad), ".oven/%s/chef/.hash", options->name);
    hashFile = fopen(&scratchPad[0], "w");
    if (hashFile == NULL) {
        VLOG_TRACE("oven", "__read_hash: no hash file");
        return 0;
    }

    hash = __setup_hash(options);
    fprintf(hashFile, "%u", hash);
    fclose(hashFile);
    return 0;
}

static int __should_skip_setup(struct scratch_options* options)
{
    unsigned int currentHash  = __setup_hash(options);
    unsigned int existingHash = __read_hash(options->name);
    return currentHash == existingHash;
}

static int __scratch_construct(struct scratch_options* options, struct scratch* scratch)
{
    char scratchPad[512];
    VLOG_DEBUG("oven", "__scratch_construct(name=%s)", options->name);

    snprintf(&scratchPad[0], sizeof(scratchPad), ".oven/%s/chef/build", options->name);
    scratch->host_build_path = strdup(&scratchPad[0]);

    snprintf(&scratchPad[0], sizeof(scratchPad), ".oven/%s/chef/.checkpoint", options->name);
    scratch->host_checkpoint_path = strdup(&scratchPad[0]);
    if (scratch->host_build_path == NULL || scratch->host_checkpoint_path == NULL) {
        free(scratch->host_build_path);
        return -1;
    }
    return 0;
}

// debootstrap --variant=minbase --include=nano,gcc,clang,tcc,pcc,g++,git,make --arch=i386 stable /stable-chroot http://deb.debian.org/debian/
int scratch_setup(struct scratch_options* options, struct scratch* scratch)
{
    char  scratchPad[512];
    char* includes;
    int   status;
    VLOG_DEBUG("oven", "scratch_setup(name=%s)", options->name);

    if (platform_spawn("debootstrap", "--version", NULL, NULL)) {
        VLOG_ERROR("oven", "scratch_setup: \"debootstrap\" package must be installed");
        return -1;
    }

    if (__should_skip_setup(options)) {
        return __scratch_construct(options, scratch);
    }

    includes = __build_include_string(options->imports);
    if (includes != NULL) {
        snprintf(&scratchPad[0], sizeof(scratchPad), "--variant=minbase %s stable .oven/%s http://deb.debian.org/debian/", includes, options->name);
        free(includes);
    } else {
        snprintf(&scratchPad[0], sizeof(scratchPad), "--variant=minbase stable .oven/%s http://deb.debian.org/debian/", options->name);
    }

    status = platform_spawn("debootstrap", &scratchPad[0], NULL, NULL);
    if (status) {
        VLOG_ERROR("oven", "scratch_setup: \"debootstrap\" failed: %i", status);
        return -1;
    }

    snprintf(&scratchPad[0], sizeof(scratchPad), ".oven/%s/chef/build", options->name);
    if (platform_mkdir(&scratchPad[0])) {
        VLOG_ERROR("oven", "scratch_setup: failed to create %s", &scratchPad[0]);
        return -1;
    }

    snprintf(&scratchPad[0], sizeof(scratchPad), ".oven/%s/chef/install", options->name);
    if (platform_symlink(&scratchPad[0], options->install_path, 1)) {
        VLOG_ERROR("oven", "scratch_setup: failed to link %s", &scratchPad[0]);
        return -1;
    }

    snprintf(&scratchPad[0], sizeof(scratchPad), ".oven/%s/chef/project", options->name);
    if (platform_symlink(&scratchPad[0], options->project_path, 1)) {
        VLOG_ERROR("oven", "scratch_setup: failed to link %s", &scratchPad[0]);
        return -1;
    }

    // extract os/ingredients/toolchain
    snprintf(&scratchPad[0], sizeof(scratchPad), ".oven/%s", options->name);
    if (__setup_ingredients(&scratchPad[0], options->ingredients)) {
        return -1;
    }

    // write hash
    if (__write_hash(options)) {
        return -1;
    }
    
    if (__scratch_construct(options, scratch)) {
        return -1;
    }
    return 0;
}

int scratch_enter(struct scratch* scratch)
{
    // Open the current root as a file-descriptor so we can restore

    // Change working directory to new project directory /chef/project

    // 
}

int scratch_leave(struct scratch* scratch)
{
    
}
